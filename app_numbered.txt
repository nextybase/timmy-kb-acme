   1: from __future__ import annotations
   2:
   3: # Nessun side-effect a import time: bootstrap e tutti gli import vivono in main().
   4:
   5:
   6: def main() -> None:
   7:     # =========================================================================
   8:     # Bootstrap path (posticipato per evitare E402 e side-effects)
   9:     # =========================================================================
  10:     import sys
  11:     from pathlib import Path
  12:
  13:     ROOT = Path(__file__).resolve().parent
  14:     SRC = ROOT / "src"
  15:     if str(SRC) not in sys.path:
  16:         sys.path.insert(0, str(SRC))
  17:
  18:     # =========================================================================
  19:     # Import locali (lazy) – dopo bootstrap
  20:     # =========================================================================
  21:     import logging
  22:     import os
  23:     import subprocess
  24:     from types import SimpleNamespace
  25:     from typing import Any, Dict, Optional, cast
  26:
  27:     import streamlit as st
  28:
  29:     from pipeline.config_utils import (
  30:         bump_n_ver_if_needed,
  31:         get_client_config,
  32:         set_data_ver_today,
  33:         update_config_with_drive_ids,
  34:     )
  35:     from pipeline.context import ClientContext
  36:     from pipeline.env_utils import compute_redact_flag, ensure_dotenv_loaded
  37:     from pipeline.logging_utils import get_structured_logger  # fix import
  38:     from pipeline.path_utils import ensure_within_and_resolve, open_for_read_bytes_selfguard
  39:
  40:     # Semantica API (niente get_paths: i path vengono dal ClientContext)
  41:     from semantic.api import convert_markdown as sem_convert
  42:     from semantic.api import enrich_frontmatter as sem_enrich
  43:     from semantic.api import load_reviewed_vocab as sem_load_vocab
  44:     from semantic.api import write_summary_and_readme as sem_write_md
  45:
  46:     # UI/Config helpers
  47:     from ui.components.mapping_editor import (
  48:         build_mapping,
  49:         load_default_mapping,
  50:         load_tags_reviewed,
  51:         save_tags_reviewed,
  52:         split_mapping,
  53:         validate_categories,
  54:     )
  55:
  56:     # Landing (modulo esterno)
  57:     from ui.landing_slug import render_landing_slug
  58:     from ui.services.drive_runner import build_drive_from_mapping, download_raw_from_drive, emit_readmes_for_raw
  59:     from ui.tabs.finance import render_finance_tab
  60:     from ui.tabs.preview import render_preview_controls
  61:
  62:     # =========================================================================
  63:     # Helpers (chiudono su import locali)
  64:     # =========================================================================
  65:     # Carica .env una sola volta (idempotente) per rendere disponibili SERVICE_ACCOUNT_FILE/DRIVE_ID
  66:     try:
  67:         ensure_dotenv_loaded()
  68:     except Exception:
  69:         pass
  70:
  71:     def _safe_compute_redact_flag(env: Optional[Dict[str, str]] = None, level: str = "INFO") -> bool:
  72:         env = env or dict(os.environ)
  73:         try:
  74:             return bool(compute_redact_flag(env, level))
  75:         except Exception:
  76:             val = (env.get("LOG_REDACTION") or env.get("LOG_REDACTED") or "").lower()
  77:             if val in {"1", "true", "yes", "on"}:
  78:                 return True
  79:             return (env.get("ENV") or "").lower() in {"prod", "production"}
  80:
  81:     def _safe_get_logger(name: str, redact: bool) -> logging.Logger:
  82:         try:
  83:             ctx = SimpleNamespace(redact_logs=bool(redact))
  84:             logger_obj = get_structured_logger(name, context=ctx)
  85:             return cast(logging.Logger, logger_obj)
  86:         except Exception:
  87:             logging.basicConfig(
  88:                 level=logging.INFO,
  89:                 format="%(asctime)s %(levelname)s: %(message)s",
  90:             )
  91:             return logging.getLogger(name)
  92:
  93:     def _request_shutdown(log: logging.Logger) -> None:
  94:         import signal
  95:
  96:         try:
  97:             log.info({"event": "ui_shutdown_request"})
  98:             os.kill(os.getpid(), signal.SIGTERM)
  99:         except Exception:
 100:             os._exit(0)
 101:
 102:     def _norm_str(val: Optional[str]) -> str:
 103:         return val.strip() if isinstance(val, str) else ""
 104:
 105:     def _safe_streamlit_rerun() -> None:
 106:         fn = getattr(st, "rerun", None) or getattr(st, "experimental_rerun", None)
 107:         if callable(fn):
 108:             try:
 109:                 fn()
 110:             except Exception:
 111:                 pass
 112:
 113:     def _ensure_context(slug: str, log: logging.Logger) -> ClientContext:
 114:         # Nessun prompt; env non obbligatorio per operazioni locali
 115:         return ClientContext.load(
 116:             slug=slug,
 117:             interactive=False,
 118:             require_env=False,
 119:             run_id=None,
 120:         )
 121:
 122:     def _mark_modified_and_bump_once(
 123:         slug: str, log: logging.Logger, *, context: Optional[ClientContext] = None
 124:     ) -> None:
 125:         try:
 126:             if (not bool(st.session_state.get("bumped"))) and bump_n_ver_if_needed is not None:
 127:                 ctx = context if context is not None else _ensure_context(slug, log)
 128:                 bump_n_ver_if_needed(ctx, log)
 129:                 st.session_state["bumped"] = True
 130:             st.session_state["modified"] = True
 131:         except Exception:
 132:             pass
 133:
 134:     # =========================================================================
 135:     # Sezioni UI (modulari)
 136:     # =========================================================================
 137:     def _render_config_tab(log: logging.Logger, slug: str, client_name: str) -> None:
 138:         st.subheader("Configurazione (mapping semantico)")
 139:         try:
 140:             mapping = load_tags_reviewed(slug)
 141:         except Exception:
 142:             mapping = load_default_mapping()
 143:
 144:         cats, reserved = split_mapping(mapping)
 145:         normalize_keys = st.toggle(
 146:             "Normalizza chiavi in kebab-case",
 147:             value=True,
 148:             help="Applica SSoT di normalizzazione",
 149:             key="tgl_norm_keys",
 150:         )
 151:         col1, col2 = st.columns([1, 1])
 152:
 153:         with col1:
 154:             st.caption("Panoramica categorie (solo lettura).")
 155:             st.json(cats, expanded=False)
 156:
 157:         with col2:
 158:             st.caption("Modifica voci (una alla volta).")
 159:             for idx, cat_key in enumerate(sorted(cats.keys(), key=str)):
 160:                 meta = cats.get(cat_key, {})
 161:                 with st.expander(cat_key, expanded=False):
 162:                     amb = st.text_input(
 163:                         f"Ambito - {cat_key}",
 164:                         value=str(meta.get("ambito", "")),
 165:                         key=f"amb_{idx}_{cat_key}",
 166:                     )
 167:                     desc = st.text_area(
 168:                         f"Descrizione - {cat_key}",
 169:                         value=str(meta.get("descrizione", "")),
 170:                         height=120,
 171:                         key=f"desc_{idx}_{cat_key}",
 172:                     )
 173:                     examples_str = "\n".join([str(x) for x in (meta.get("keywords") or [])])
 174:                     ex = st.text_area(
 175:                         f"Esempi (uno per riga) - {cat_key}",
 176:                         value=examples_str,
 177:                         height=120,
 178:                         key=f"ex_{idx}_{cat_key}",
 179:                     )
 180:
 181:                     if st.button(
 182:                         f"Salva {cat_key}",
 183:                         key=f"btn_save_cat_{idx}_{cat_key}",
 184:                         use_container_width=True,
 185:                     ):
 186:                         try:
 187:                             new_cats = dict(cats)
 188:                             new_cats[cat_key] = {
 189:                                 "ambito": amb.strip(),
 190:                                 "descrizione": desc.strip(),
 191:                                 "keywords": [ln.strip() for ln in ex.splitlines() if ln.strip()],
 192:                             }
 193:                             err = validate_categories(new_cats, normalize_keys=normalize_keys)
 194:                             if err:
 195:                                 st.error(f"Errore: {err}")
 196:                             else:
 197:                                 new_map = build_mapping(
 198:                                     new_cats,
 199:                                     reserved,
 200:                                     slug=slug,
 201:                                     client_name=client_name,
 202:                                     normalize_keys=normalize_keys,
 203:                                 )
 204:                                 path = save_tags_reviewed(slug, new_map)
 205:                                 log.info(
 206:                                     {
 207:                                         "event": "tags_reviewed_saved_item",
 208:                                         "slug": slug,
 209:                                         "cat": cat_key,
 210:                                         "path": str(path),
 211:                                     }
 212:                                 )
 213:                                 _mark_modified_and_bump_once(slug, log)
 214:                                 st.success(f"Salvata la voce: {cat_key}")
 215:                                 _safe_streamlit_rerun()
 216:                         except Exception as e:
 217:                             st.exception(e)
 218:
 219:             st.caption(("Suggerimento: usa il pulsante Salva dentro ogni voce per applicare modifiche puntuali."))
 220:
 221:         colSx, colDx = st.columns([1, 1])
 222:         with colSx:
 223:             if st.button("Valida mapping", key="btn_validate_mapping", use_container_width=True):
 224:                 err = validate_categories(cats, normalize_keys=normalize_keys)
 225:                 st.success("Mapping valido.") if not err else st.error(f"Errore: {err}")
 226:         with colDx:
 227:             if st.button(
 228:                 "Salva mapping rivisto",
 229:                 key="btn_save_mapping_all",
 230:                 type="primary",
 231:                 use_container_width=True,
 232:             ):
 233:                 try:
 234:                     new_map = build_mapping(
 235:                         cats,
 236:                         reserved,
 237:                         slug=slug,
 238:                         client_name=client_name,
 239:                         normalize_keys=normalize_keys,
 240:                     )
 241:                     path = save_tags_reviewed(slug, new_map)
 242:                     st.success(f"Salvato: {path}")
 243:                     log.info({"event": "tags_reviewed_saved_all", "slug": slug, "path": str(path)})
 244:                     _mark_modified_and_bump_once(slug, log)
 245:                 except Exception as e:
 246:                     st.exception(e)
 247:
 248:     def _render_drive_tab(log: logging.Logger, slug: str) -> None:
 249:         st.subheader("Drive")
 250:         st.caption(
 251:             "Crea la struttura su Drive a partire dal mapping rivisto e genera i README "
 252:             "nelle sottocartelle di `raw/`."
 253:         )
 254:
 255:         # Verifica dipendenze Drive
 256:         try:
 257:             from googleapiclient.http import MediaIoBaseDownload as _chk
 258:
 259:             _ = _chk
 260:             dep_ok = True
 261:         except Exception:
 262:             dep_ok = False
 263:
 264:         if not dep_ok:
 265:             st.warning(
 266:                 "Funzionalità Drive non disponibili: dipendenza mancante "
 267:                 "`google-api-python-client`.\n"
 268:                 "Installa il pacchetto e riavvia la UI. Esempio: "
 269:                 "`pip install google-api-python-client`.",
 270:                 icon="⚠️",
 271:             )
 272:             return
 273:
 274:         # Preflight credenziali
 275:         with st.expander("Preflight Drive", expanded=False):
 276:             saf = os.getenv("SERVICE_ACCOUNT_FILE") or ""
 277:             did = os.getenv("DRIVE_ID") or ""
 278:
 279:             def _mask_path(p: str) -> str:
 280:                 from pathlib import Path as _P
 281:
 282:                 try:
 283:                     return _P(p).name if p else "(unset)"
 284:                 except Exception:
 285:                     return "(invalid)"
 286:
 287:             def _mask_id(s: str) -> str:
 288:                 return (s[:6] + " …") if s else "(unset)"
 289:
 290:             st.write(f"SERVICE_ACCOUNT_FILE: {_mask_path(saf)}")
 291:             st.write(f"DRIVE_ID: {_mask_id(did)}")
 292:
 293:             if st.button("Verifica credenziali Drive", key="btn_drive_preflight", use_container_width=True):
 294:                 try:
 295:                     from pipeline.drive_utils import get_drive_service
 296:
 297:                     ctx = ClientContext.load(slug=slug, interactive=False, require_env=True, run_id=None)
 298:                     svc = get_drive_service(ctx)
 299:                     _ = svc.about().get(fields="user").execute()
 300:                     st.success("OK: credenziali e accesso Drive verificati.")
 301:                 except Exception as e:
 302:                     st.exception(e)
 303:
 304:         colA, colB = st.columns([1, 1], gap="large")
 305:
 306:         with colA:
 307:             if st.button(
 308:                 "1) Crea/aggiorna struttura Drive",
 309:                 key="btn_drive_create",
 310:                 use_container_width=True,
 311:             ):
 312:                 try:
 313:                     prog = st.progress(0)
 314:                     status = st.empty()
 315:
 316:                     def _cb(step: int, total: int, label: str) -> None:
 317:                         pct = int(step * 100 / max(total, 1))
 318:                         prog.progress(pct)
 319:                         status.markdown(f"{pct}% - {label}")
 320:
 321:                     ids = build_drive_from_mapping(
 322:                         slug=slug,
 323:                         client_name=st.session_state.get("client_name", ""),
 324:                         progress=_cb,
 325:                     )
 326:                     st.success(f"Struttura creata: {ids}")
 327:                     log.info({"event": "drive_structure_created", "slug": slug, "ids": ids})
 328:                 except FileNotFoundError as e:
 329:                     st.error(
 330:                         "Mapping non trovato per questo cliente. Apri la tab 'Configurazione', "
 331:                         "verifica/modifica il mapping e premi 'Salva mapping rivisto', poi riprova."
 332:                     )
 333:                     st.caption(f"Dettagli: {e}")
 334:                 except Exception as e:
 335:                     st.exception(e)
 336:         with colB:
 337:             if st.button(
 338:                 "2) Genera README in raw/",
 339:                 key="btn_drive_readmes",
 340:                 type="primary",
 341:                 use_container_width=True,
 342:             ):
 343:                 try:
 344:                     result = emit_readmes_for_raw(slug=slug, ensure_structure=True)
 345:                     st.success(f"README creati: {len(result)}")
 346:                     log.info({"event": "raw_readmes_uploaded", "slug": slug, "count": len(result)})
 347:                     st.session_state["drive_readmes_done"] = True
 348:                     _mark_modified_and_bump_once(slug, log)
 349:                 except FileNotFoundError as e:
 350:                     st.error(
 351:                         "Mapping non trovato per questo cliente. Apri la tab 'Configurazione', "
 352:                         "verifica/modifica il mapping e premi 'Salva mapping rivisto', poi riprova."
 353:                     )
 354:                     st.caption(f"Dettagli: {e}")
 355:                 except Exception as e:
 356:                     st.exception(e)
 357:
 358:         # Download PDF → raw/ (solo dopo README)
 359:         if st.session_state.get("drive_readmes_done"):
 360:             st.markdown("---")
 361:             st.subheader("Download contenuti su raw/")
 362:             c1, c2 = st.columns([1, 3])
 363:             with c1:
 364:                 if st.button(
 365:                     "Scarica PDF da Drive in raw/",
 366:                     key="btn_drive_download_raw",
 367:                     use_container_width=True,
 368:                 ):
 369:                     if download_raw_from_drive is None:
 370:                         st.error(("Funzione di download non disponibile: aggiornare 'ui.services.drive_runner'."))
 371:                     else:
 372:                         try:
 373:                             prog = st.progress(0)
 374:                             status = st.empty()
 375:                             try:
 376:                                 from ui.services.drive_runner import download_raw_from_drive_with_progress
 377:
 378:                                 def _pcb(done: int, total: int, label: str) -> None:
 379:                                     pct = int((done * 100) / max(total, 1))
 380:                                     prog.progress(pct)
 381:                                     status.markdown(f"{pct}% - {label}")
 382:
 383:                                 res = download_raw_from_drive_with_progress(slug=slug, on_progress=_pcb)
 384:                             except Exception:
 385:                                 res = download_raw_from_drive(slug=slug)
 386:                             count = len(res) if hasattr(res, "__len__") else None
 387:                             msg_tail = f" ({count} file)" if count is not None else ""
 388:                             st.success(f"Download completato{msg_tail}.")
 389:                             log.info({"event": "drive_raw_downloaded", "slug": slug, "count": count})
 390:                             st.session_state["raw_downloaded"] = True
 391:                             st.session_state["raw_ready"] = True
 392:                             _safe_streamlit_rerun()
 393:                         except Exception as e:
 394:                             st.exception(e)
 395:                 st.markdown("")
 396:                 if st.button(
 397:                     "Rileva PDF in raw/",
 398:                     key="btn_drive_detect_raw_ready",
 399:                     use_container_width=True,
 400:                 ):
 401:                     try:
 402:                         ctx = _ensure_context(slug, log)
 403:                         raw_dir = getattr(ctx, "raw_dir", None)
 404:                         # --- base_dir sicuro (no Optional / None) ---
 405:                         has_pdfs = any(raw_dir.rglob("*.pdf")) if (raw_dir and raw_dir.exists()) else False
 406:                         has_csv = False
 407:                         base_dir_opt = getattr(ctx, "base_dir", None)
 408:                         if raw_dir and raw_dir.exists():
 409:                             base_dir_safe = raw_dir.parent
 410:                         elif isinstance(base_dir_opt, Path):
 411:                             base_dir_safe = base_dir_opt
 412:                         else:
 413:                             base_dir_safe = None
 414:                         if isinstance(base_dir_safe, Path):
 415:                             has_csv = (base_dir_safe / "semantic" / "tags_raw.csv").exists()
 416:                         # ------------------------------------------
 417:                         st.session_state["raw_ready"] = bool(has_pdfs or has_csv)
 418:                         st.success(
 419:                             "Rilevazione completata: "
 420:                             + (
 421:                                 "PDF trovati o CSV presente."
 422:                                 if st.session_state["raw_ready"]
 423:                                 else "nessun PDF rilevato."
 424:                             )
 425:                         )
 426:                         _safe_streamlit_rerun()
 427:                     except Exception as e:
 428:                         st.exception(e)
 429:             with c2:
 430:                 st.write(
 431:                     "La struttura delle cartelle è stata creata su Drive; popolare i contenuti "
 432:                     "seguendo le indicazioni del README presente in ogni cartella per proseguire."
 433:                 )
 434:
 435:     def _render_semantic_tab(log: logging.Logger, slug: str) -> None:
 436:         st.subheader("Semantica (RAW → BOOK)")
 437:         st.caption(
 438:             "Converte i PDF in Markdown, arricchisce i frontmatter e genera README/SUMMARY. "
 439:             "Preview Docker opzionale."
 440:         )
 441:
 442:         if any(x is None for x in (sem_convert, sem_enrich, sem_write_md, sem_load_vocab)):
 443:             st.error("Modulo semantic.api non disponibile o import parziale. Verificare l'ambiente.")
 444:             return
 445:
 446:         try:
 447:             context = _ensure_context(slug, log)
 448:         except Exception as e:
 449:             st.exception(e)
 450:             return
 451:
 452:         colA, colB = st.columns([1, 1], gap="large")
 453:
 454:         with colA:
 455:             st.markdown("<div class='next-card'>", unsafe_allow_html=True)
 456:             st.markdown("**1) Conversione RAW → BOOK**")
 457:             st.caption("Converte i PDF in Markdown (cartella book/).")
 458:             if st.button("Converti PDF in Markdown", key="btn_sem_convert", use_container_width=True):
 459:                 try:
 460:                     mds = sem_convert(context, log, slug=slug)
 461:                     st.success(f"OK. File Markdown in book/: {len(mds)}")
 462:                     log.info(
 463:                         {
 464:                             "event": "semantic_convert_done",
 465:                             "slug": slug,
 466:                             "run_id": st.session_state.get("run_id"),
 467:                             "md_count": len(mds),
 468:                         }
 469:                     )
 470:                     _mark_modified_and_bump_once(slug, log, context=context)
 471:                 except Exception as e:
 472:                     st.exception(e)
 473:             st.markdown("</div>", unsafe_allow_html=True)
 474:
 475:             with st.container(border=True):
 476:                 st.markdown("**2) Arricchisci frontmatter**")
 477:                 st.caption("Arricchisce i metadati con tag canonici (SQLite).")
 478:                 if st.button(
 479:                     "Arricchisci con tag canonici (SQLite)",
 480:                     key="btn_sem_enrich",
 481:                     use_container_width=True,
 482:                 ):
 483:                     try:
 484:                         # Usa il base_dir reale dal ClientContext (override inclusi)
 485:                         base_dir_opt = getattr(context, "base_dir", None)
 486:                         raw_dir_opt = getattr(context, "raw_dir", None)
 487:                         if isinstance(base_dir_opt, Path):
 488:                             base_dir_safe = base_dir_opt
 489:                         elif isinstance(raw_dir_opt, Path):
 490:                             base_dir_safe = raw_dir_opt.parent
 491:                         else:
 492:                             base_dir_safe = None
 493:                         if base_dir_safe is None:
 494:                             st.error("base_dir non disponibile nel contesto.")
 495:                         else:
 496:                             vocab = sem_load_vocab(base_dir_safe, log)
 497:                             touched = sem_enrich(context, log, vocab, slug=slug)
 498:                             st.success(f"OK. Frontmatter aggiornati: {len(touched)}")
 499:                             log.info(
 500:                                 {
 501:                                     "event": "semantic_enrich_done",
 502:                                     "slug": slug,
 503:                                     "run_id": st.session_state.get("run_id"),
 504:                                     "touched": len(touched),
 505:                                 }
 506:                             )
 507:                             _mark_modified_and_bump_once(slug, log, context=context)
 508:                     except Exception as e:
 509:                         st.exception(e)
 510:
 511:         with colB:
 512:             with st.container(border=True):
 513:                 st.markdown("**3) README/SUMMARY**")
 514:                 st.caption("Prepara e valida README.md e SUMMARY.md.")
 515:                 if st.button(
 516:                     "Genera/valida README & SUMMARY",
 517:                     key="btn_sem_write_md",
 518:                     use_container_width=True,
 519:                 ):
 520:                     try:
 521:                         sem_write_md(context, log, slug=slug)
 522:                         st.success("OK. README.md e SUMMARY.md pronti.")
 523:                         log.info(
 524:                             {
 525:                                 "event": "semantic_write_md_done",
 526:                                 "slug": slug,
 527:                                 "run_id": st.session_state.get("run_id"),
 528:                             }
 529:                         )
 530:                         _mark_modified_and_bump_once(slug, log, context=context)
 531:                     except Exception as e:
 532:                         st.exception(e)
 533:
 534:             # Preview (modulo estratto)
 535:             render_preview_controls(st=st, context=context, log=log, slug=slug)
 536:
 537:         st.divider()
 538:         st.caption(
 539:             "Nota: questo step **non** usa Google Drive né esegue push su GitHub; "
 540:             "lavora su disco locale ed espone una preview."
 541:         )
 542:
 543:     # =========================================================================
 544:     # Page config + stile (nessuna riga >120)
 545:     # =========================================================================
 546:     try:
 547:         _fav = ROOT / "assets" / "ico-next.png"
 548:         if _fav.exists():
 549:             st.set_page_config(
 550:                 page_title="NeXT - Onboarding UI",
 551:                 layout="wide",
 552:                 page_icon=str(_fav),
 553:             )
 554:         else:
 555:             st.set_page_config(page_title="NeXT - Onboarding UI", layout="wide")
 556:     except Exception:
 557:         st.set_page_config(page_title="NeXT - Onboarding UI", layout="wide")
 558:
 559:     st.markdown(
 560:         """
 561:         <style>
 562:         #MainMenu { visibility: hidden; }
 563:         footer { visibility: hidden; }
 564:         .stButton > button {
 565:             background: #F2B400 !important;
 566:             color: #111827 !important;
 567:             border-radius: 10px !important;
 568:             font-weight: 600 !important;
 569:             border: 1px solid #e5e7eb !important;
 570:         }
 571:         .stButton > button:hover {
 572:             filter: brightness(0.98);
 573:         }
 574:         .next-card {
 575:             border: 1px solid #e5e7eb;
 576:             border-radius: 12px;
 577:             padding: 16px 18px;
 578:             background: #ffffff;
 579:         }
 580:         .pill {
 581:             display: inline-block;
 582:             padding: 4px 12px;
 583:             border-radius: 9999px;
 584:             font-weight: 600;
 585:             border: 1px solid #f5d98b;
 586:         }
 587:         .pill.off {
 588:             background: #FEF3C7;
 589:             color: #6B7280;
 590:         }
 591:         .pill.on  {
 592:             background: #FDE68A;
 593:             color: #1F2937;
 594:         }
 595:         [data-testid="stSidebar"] [data-testid="stRadio"]
 596:         div[role="radiogroup"] {
 597:             display: flex;
 598:             flex-direction: column;
 599:             gap: 6px;
 600:         }
 601:         [data-testid="stSidebar"] [data-testid="stRadio"]
 602:         div[role="radiogroup"] > label {
 603:             display: block;
 604:             padding: 8px 12px;
 605:             border-radius: 10px;
 606:             color: #111827;
 607:             cursor: pointer;
 608:             border: 1px solid #e5e7eb;
 609:             background: #ffffff;
 610:             font-weight: 600;
 611:         }
 612:         [data-testid="stSidebar"] [data-testid="stRadio"]
 613:         div[role="radiogroup"] > label:hover {
 614:             background: #FDF6B2;
 615:         }
 616:         [data-testid="stSidebar"] [data-testid="stRadio"]
 617:         div[role="radiogroup"] > label > div[role="radio"] {
 618:             display: none;
 619:         }
 620:         [data-testid="stSidebar"] [data-testid="stRadio"]
 621:         div[role="radiogroup"]
 622:         > label:has(div[role="radio"][aria-checked="true"]) {
 623:             background: #FDE68A;
 624:             border: 1px solid #f5d98b;
 625:         }
 626:         [data-testid="stSidebar"] [data-testid="stRadio"]
 627:         div[role="radiogroup"]
 628:         > label:has(div[role="radio"][aria-checked="true"])
 629:         div[role="radio"][aria-checked="true"] {
 630:             background: #FDE68A;
 631:             border: 1px solid #f5d98b;
 632:             border-radius: 10px;
 633:             padding: 8px 12px;
 634:             font-weight: 700;
 635:         }
 636:         </style>
 637:         """,
 638:         unsafe_allow_html=True,
 639:     )
 640:
 641:     redact = _safe_compute_redact_flag()
 642:     log = _safe_get_logger("onboarding_ui", redact)
 643:
 644:     # run_id per correlazione log UI
 645:     try:
 646:         import uuid as _uuid
 647:
 648:         if not st.session_state.get("run_id"):
 649:             st.session_state["run_id"] = _uuid.uuid4().hex
 650:     except Exception:
 651:         pass
 652:
 653:     # Flag di sessione per versioning
 654:     st.session_state.setdefault("modified", False)
 655:     st.session_state.setdefault("bumped", False)
 656:
 657:     # =========================================================================
 658:     # Landing (gating iniziale)
 659:     # =========================================================================
 660:     if not st.session_state.get("client_locked", False):
 661:         locked, _, _ = render_landing_slug(log)
 662:         top_l, top_r = st.columns([4, 1])
 663:         with top_r:
 664:             if st.button(
 665:                 "Esci",
 666:                 key="btn_exit_landing",
 667:                 help="Chiude l'interfaccia Streamlit e termina il processo.",
 668:                 use_container_width=True,
 669:             ):
 670:                 try:
 671:                     log.info({"event": "ui_exit_requested", "slug": st.session_state.get("slug", "-")})
 672:                 except Exception:
 673:                     pass
 674:                 _request_shutdown(log)
 675:         if not locked:
 676:             return  # Finché non è lockato, non mostrare altro
 677:
 678:     # =========================================================================
 679:     # UI completa (sidebar + contenuto)
 680:     # =========================================================================
 681:     slug = cast(str, st.session_state.get("slug", ""))
 682:     client_name = cast(str, st.session_state.get("client_name", ""))
 683:
 684:     st.session_state["sidebar_active"] = False
 685:     if st.session_state.get("client_locked", False):
 686:         with st.sidebar:
 687:             st.session_state["sidebar_active"] = True
 688:             # Branding (silenzioso se assente)
 689:             try:
 690:                 _logo = ROOT / "assets" / "next-logo.png"
 691:                 if _logo.exists():
 692:                     import base64 as _b64
 693:
 694:                     logo_path = ensure_within_and_resolve(ROOT, _logo)
 695:                     with open_for_read_bytes_selfguard(logo_path) as logo_file:
 696:                         _data = logo_file.read()
 697:                     _b64s = _b64.b64encode(_data).decode("ascii")
 698:                     st.markdown(
 699:                         "<img src='data:image/png;base64,{data}' alt='NeXT' "
 700:                         "style='width:100%;height:auto;display:block;' />".format(data=_b64s),
 701:                         unsafe_allow_html=True,
 702:                     )
 703:             except Exception:
 704:                 pass
 705:
 706:             # Menù (aggiunge Finanza se cliente lockato)
 707:             st.subheader("Menù")
 708:             _menu_items = ["Configurazione", "Drive"]
 709:             if st.session_state.get("client_locked"):
 710:                 _menu_items.append("Finanza")
 711:             _menu_items += ["Semantica", "Preview"]
 712:
 713:             _current = cast(str, st.session_state.get("active_section") or "Configurazione")
 714:             try:
 715:                 _default_index = _menu_items.index(_current) if _current in _menu_items else 0
 716:             except Exception:
 717:                 _default_index = 0
 718:             _choice = st.radio(
 719:                 label="Sezione",
 720:                 options=_menu_items,
 721:                 index=_default_index,
 722:                 key="sidebar_menu",
 723:                 label_visibility="collapsed",
 724:             )
 725:             if _choice != _current:
 726:                 st.session_state["active_section"] = _choice
 727:                 _safe_streamlit_rerun()
 728:
 729:             # Impostazioni retriever (config cliente)
 730:             with st.expander("Ricerca (retriever)", expanded=False):
 731:                 cfg: Dict[str, Any] = {}
 732:                 try:
 733:                     _ctx_read = _ensure_context(slug, log)
 734:                     cfg = get_client_config(_ctx_read) or {}
 735:                 except Exception:
 736:                     cfg = {}
 737:
 738:                 retr = dict(cfg.get("retriever") or {})
 739:                 try:
 740:                     current_limit = int(retr.get("candidate_limit", 4000) or 4000)
 741:                 except Exception:
 742:                     current_limit = 4000
 743:                 try:
 744:                     current_budget = int(retr.get("latency_budget_ms", 0) or 0)
 745:                 except Exception:
 746:                     current_budget = 0
 747:                 auto_flag = bool(retr.get("auto_by_budget", False))
 748:
 749:                 st.caption(("Imposta il limite candidati per il ranking. Valori più alti aumentano la latenza."))
 750:                 new_limit = st.number_input(
 751:                     "candidate_limit",
 752:                     min_value=500,
 753:                     max_value=20000,
 754:                     step=500,
 755:                     value=int(current_limit),
 756:                     help="Numero massimo di candidati da considerare (default: 4000).",
 757:                     key="inp_retr_limit",
 758:                 )
 759:                 new_budget = st.number_input(
 760:                     "budget di latenza (ms)",
 761:                     min_value=0,
 762:                     max_value=10000,
 763:                     step=50,
 764:                     value=int(current_budget),
 765:                     help="0 = disabilitato. Usato solo come riferimento operativo.",
 766:                     key="inp_retr_budget",
 767:                 )
 768:                 new_auto = st.toggle(
 769:                     "Auto per budget",
 770:                     value=bool(auto_flag),
 771:                     help=("Se attivo, il sistema sceglie automaticamente candidate_limit in base al budget."),
 772:                     key="tgl_retr_auto",
 773:                 )
 774:
 775:                 # Stima limite se auto+budget
 776:                 if bool(new_auto) and int(new_budget) > 0:
 777:                     try:
 778:                         from src.retriever import choose_limit_for_budget
 779:
 780:                         est = choose_limit_for_budget(int(new_budget))
 781:                     except Exception:
 782:                         est = None
 783:                     if est:
 784:                         st.caption(f"Limite stimato in base al budget: {int(est)}")
 785:
 786:                 colL, colR = st.columns([1, 1])
 787:                 with colL:
 788:                     if st.button("Salva impostazioni retriever", key="btn_save_retriever"):
 789:                         try:
 790:                             lim = max(500, min(20000, int(new_limit)))
 791:                             bud = max(0, min(10000, int(new_budget)))
 792:                             ctx = _ensure_context(slug, log)
 793:                             try:
 794:                                 cfg_now = get_client_config(ctx) or {}
 795:                             except Exception:
 796:                                 cfg_now = {}
 797:                             retr_prev = dict((cfg_now.get("retriever") or {}))
 798:                             retr_prev.update(
 799:                                 {
 800:                                     "candidate_limit": lim,
 801:                                     "latency_budget_ms": bud,
 802:                                     "auto_by_budget": bool(new_auto),
 803:                                 }
 804:                             )
 805:                             update_config_with_drive_ids(ctx, updates={"retriever": retr_prev}, logger=log)
 806:                             _mark_modified_and_bump_once(slug, log)
 807:                             st.success("Impostazioni salvate nel config del cliente.")
 808:                         except Exception as e:
 809:                             st.exception(e)
 810:                 with colR:
 811:                     st.caption(("Calibra con 1000/2000/4000 e scegline il più piccolo che rispetta il budget."))
 812:
 813:             # Tools
 814:             st.subheader("Tools")
 815:             if st.button(
 816:                 "Genera/Aggiorna dummy",
 817:                 key="btn_dummy",
 818:                 help=(
 819:                     "Genera/aggiorna un utente e un dataset dummy per lo slug corrente.\n"
 820:                     "Utile per test locali della pipeline senza materiali reali."
 821:                 ),
 822:             ):
 823:                 slug_local = slug
 824:                 with st.spinner("Generazione dummy in corso…"):
 825:                     try:
 826:                         log.info({"event": "ui_dummy_generate_start", "slug": slug_local})
 827:                         # Usa l'interprete corrente per robustezza cross-platform
 828:                         proc = subprocess.run(
 829:                             [sys.executable, "src/tools/gen_dummy_kb.py", "--slug", slug_local],
 830:                             capture_output=True,
 831:                             text=True,
 832:                             check=False,
 833:                         )
 834:                         log.info(
 835:                             {
 836:                                 "event": "ui_dummy_generate_end",
 837:                                 "slug": slug_local,
 838:                                 "returncode": proc.returncode,
 839:                             }
 840:                         )
 841:                         if proc.returncode == 0:
 842:                             st.success("Dummy generato/aggiornato.")
 843:                         else:
 844:                             st.error(f"Dummy: errore (code {proc.returncode})")
 845:                             if proc.stderr:
 846:                                 st.code(proc.stderr[:4000])
 847:                         if proc.stdout:
 848:                             st.code(proc.stdout[:4000])
 849:                     except Exception as e:
 850:                         st.error(f"Eccezione durante la generazione dummy: {e}")
 851:                         try:
 852:                             log.error(
 853:                                 {
 854:                                     "event": "ui_dummy_generate_exception",
 855:                                     "slug": slug_local,
 856:                                     "error": str(e).splitlines()[:1],
 857:                                 }
 858:                             )
 859:                         except Exception:
 860:                             pass
 861:
 862:             if st.button(
 863:                 "Esci",
 864:                 key="btn_exit_sidebar",
 865:                 help="Chiude l'interfaccia Streamlit e termina il processo.",
 866:             ):
 867:                 try:
 868:                     log.info({"event": "ui_exit_requested", "slug": slug})
 869:                     if bool(st.session_state.get("modified")) and set_data_ver_today is not None:
 870:                         ctx = _ensure_context(slug, log)
 871:                         set_data_ver_today(ctx, log)
 872:                 except Exception:
 873:                     pass
 874:                 _request_shutdown(log)
 875:
 876:     # Header pagina
 877:     st.title("NeXT Onboarding")
 878:     st.markdown(f"**Cliente:** {client_name} | **Slug:** `{slug}`")
 879:
 880:     # Gating Semantica (usa ClientContext, non sem_get_paths)
 881:     raw_ready = bool(st.session_state.get("raw_ready"))
 882:     if not raw_ready:
 883:         try:
 884:             ctx = _ensure_context(slug, log)
 885:             raw_dir = getattr(ctx, "raw_dir", None)
 886:             if raw_dir and raw_dir.exists():
 887:                 try:
 888:                     has_pdfs = any(raw_dir.rglob("*.pdf"))
 889:                 except Exception:
 890:                     has_pdfs = False
 891:             else:
 892:                 has_pdfs = False
 893:             # base_dir sicuro
 894:             has_csv = False
 895:             base_dir_opt = getattr(ctx, "base_dir", None)
 896:             if raw_dir and raw_dir.exists():
 897:                 base_dir_safe = raw_dir.parent
 898:             elif isinstance(base_dir_opt, Path):
 899:                 base_dir_safe = base_dir_opt
 900:             else:
 901:                 base_dir_safe = None
 902:             if isinstance(base_dir_safe, Path):
 903:                 has_csv = (base_dir_safe / "semantic" / "tags_raw.csv").exists()
 904:             st.session_state["raw_ready"] = bool(has_pdfs or has_csv)
 905:         except Exception:
 906:             pass
 907:
 908:     # Sidebar Menù → sezioni
 909:     active = cast(str, st.session_state.get("active_section") or "Configurazione")
 910:     if active == "Configurazione":
 911:         _render_config_tab(log, slug, client_name)
 912:     elif active == "Drive":
 913:         _render_drive_tab(log, slug)
 914:     elif active == "Finanza":
 915:         render_finance_tab(st=st, log=log, slug=slug)
 916:     elif active == "Semantica":
 917:         _render_semantic_tab(log, slug)
 918:     elif active == "Preview":
 919:         # Il tab Preview è interamente nel modulo estratto
 920:         pass
 921:
 922:
 923: if __name__ == "__main__":
 924:     main()
